#### 1 拷贝构造函数
- **拷贝构造函数**：p2 = Person(const& p1)编译器会自动生成对属性进行值拷贝
- **常用场景**：
（1）使用已经创建完毕的对象初始化新对象；
（2）值传递的方式给函数参数传值（实参拷贝给形参）；
（3）p2 = func(p1)以值方式返回局部对象；
```cpp
class Person {
public:
    // 默认构造函数
    Person() {
        cout << "调用Person默认无参构造函数" << endl;
    }
    // 有参构造函数
    Person(int age) {
        age_ = age;
        cout << "调用Person有参构造函数" << endl;
    }

    // 拷贝构造函数

    Person(const Person &p) {

        age_ = p.age_;

        cout << "调用Person拷贝构造函数" << endl;

    }

    int getAge() {

        return age_;

    }

    // 析构函数，无参不可重载

    ~Person() {

        cout << "调用Person析构函数" << endl;

    }

private:

    int age_;

};

  

// 拷贝构造函数的调用时机

// (1) 使用已经创建完毕的对象初始化新对象

void test01() {

    cout << "(1) 初始化新对象:" << endl;

    Person p1(10);

    Person p2(p1);

}

// (2) 值传递的方式给函数传值

void doWork1(Person p) {

}

void test02() {

    cout << "(2) 值传递给函数传值:" << endl;

    Person p1(10);

    doWork1(p1);

}

// (3) 以值方式返回局部对象

Person doWork2() {

    Person p1;

    cout << &p1 << endl;

    return p1;

}

void test03() {

    cout << "(3) 值方式函数返回局部对象:" << endl;

    Person p = doWork2();

    cout << &p << endl;

}

  

int main() {

    test03();

}
```

- **构造函数调用规则**：用户提供有参构造函数后，编译器只提供默认拷贝构造函数；用户提供拷贝构造函数后，编译器不提供任何构造函数；

- **深拷贝与浅拷贝**：编译器生成的默认拷贝函数为浅拷贝（只拷贝栈区属性值/堆区属性的地址），会导致析构时堆区重复释放，此时需要自己写深拷贝函数（堆区开辟空间new）；